<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Pin: Code Cache API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Code Cache API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga98bf4df2161b9cecbe77ffedfd0fd2f8"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga98bf4df2161b9cecbe77ffedfd0fd2f8">LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK</a> )()</td></tr>
<tr class="separator:ga98bf4df2161b9cecbe77ffedfd0fd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b85643fe15f437bd36330001b4ca5b"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga37b85643fe15f437bd36330001b4ca5b">LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK</a> )(USIZE new_block_size)</td></tr>
<tr class="separator:ga37b85643fe15f437bd36330001b4ca5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe86a24a3af58f9fdf9f748c17ea0a25"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabe86a24a3af58f9fdf9f748c17ea0a25">LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK</a> )(USIZE trace_size, USIZE stub_size)</td></tr>
<tr class="separator:gabe86a24a3af58f9fdf9f748c17ea0a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197457580426e1cef2a5251615a45bb6"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga197457580426e1cef2a5251615a45bb6">LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK</a> )(ADDRINT cache_pc)</td></tr>
<tr class="separator:ga197457580426e1cef2a5251615a45bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e65e760fb4fc84568a736ef3c0a062d"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3e65e760fb4fc84568a736ef3c0a062d">LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT target_pc)</td></tr>
<tr class="separator:ga3e65e760fb4fc84568a736ef3c0a062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02c7c2aa22326a08955162d2dc0448a"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gac02c7c2aa22326a08955162d2dc0448a">LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT stub_pc)</td></tr>
<tr class="separator:gac02c7c2aa22326a08955162d2dc0448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506353952adfe0fe732bed4c2c45ea5b"><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga506353952adfe0fe732bed4c2c45ea5b">LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK</a> )(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td></tr>
<tr class="separator:ga506353952adfe0fe732bed4c2c45ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17a2b32092653d2487e78dbf95505f95"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga17a2b32092653d2487e78dbf95505f95">LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga17a2b32092653d2487e78dbf95505f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379731c41320f38f44fa0fb40737d772"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga379731c41320f38f44fa0fb40737d772">LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction</a> (CODECACHE_CACHEBLOCK_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga379731c41320f38f44fa0fb40737d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f05396c442e2a2451975ab71ed9c568"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga0f05396c442e2a2451975ab71ed9c568">LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction</a> (CODECACHE_FULL_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga0f05396c442e2a2451975ab71ed9c568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75516b5a8e0a5e941f43d738a51b46d"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gac75516b5a8e0a5e941f43d738a51b46d">LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:gac75516b5a8e0a5e941f43d738a51b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3816f1497788aae88c27d7a041d37a2d"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3816f1497788aae88c27d7a041d37a2d">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga3816f1497788aae88c27d7a041d37a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903b8e0a548c984ea0fd608c1d11fec3"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga903b8e0a548c984ea0fd608c1d11fec3">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga903b8e0a548c984ea0fd608c1d11fec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3f16e42bea2a508bb9f8c3c2ad03b2"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gadb3f16e42bea2a508bb9f8c3c2ad03b2">LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction</a> (CODECACHE_LINKED_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:gadb3f16e42bea2a508bb9f8c3c2ad03b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04641b94094045fa3982373cb0281440"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga04641b94094045fa3982373cb0281440">LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction</a> (CODECACHE_UNLINKED_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:ga04641b94094045fa3982373cb0281440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c32577f894744a42be8cf0c32e0e9b"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaf2c32577f894744a42be8cf0c32e0e9b">LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction</a> (CODECACHE_TRACEINVALIDATED_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:gaf2c32577f894744a42be8cf0c32e0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39fec242a10c873fb397f5e3d523ed1"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaf39fec242a10c873fb397f5e3d523ed1">LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress</a> (ADDRINT app_pc)</td></tr>
<tr class="separator:gaf39fec242a10c873fb397f5e3d523ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54123ca5c5d213041e46c3c47d1030a1"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga54123ca5c5d213041e46c3c47d1030a1">LEVEL_PINCLIENT::CODECACHE_CodeMemReserved</a> ()</td></tr>
<tr class="separator:ga54123ca5c5d213041e46c3c47d1030a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285de63369aba24328ddaecd8511e1df"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga285de63369aba24328ddaecd8511e1df">LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed</a> ()</td></tr>
<tr class="separator:ga285de63369aba24328ddaecd8511e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d298cac03ab619c7d9575ca1bc4408"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga03d298cac03ab619c7d9575ca1bc4408">LEVEL_PINCLIENT::CODECACHE_CodeMemUsed</a> ()</td></tr>
<tr class="separator:ga03d298cac03ab619c7d9575ca1bc4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8971f6762d05f83a017263d024db3c5"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae8971f6762d05f83a017263d024db3c5">LEVEL_PINCLIENT::CODECACHE_ExitStubBytes</a> ()</td></tr>
<tr class="separator:gae8971f6762d05f83a017263d024db3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8f5165231ddc04eeb2694c58015855"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga7c8f5165231ddc04eeb2694c58015855">LEVEL_PINCLIENT::CODECACHE_LinkBytes</a> ()</td></tr>
<tr class="separator:ga7c8f5165231ddc04eeb2694c58015855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12252f735d860ac0288435c0db72a9b"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaa12252f735d860ac0288435c0db72a9b">LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit</a> ()</td></tr>
<tr class="separator:gaa12252f735d860ac0288435c0db72a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf55a4da7c062b4fedb4544d5ef95981"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaaf55a4da7c062b4fedb4544d5ef95981">LEVEL_PINCLIENT::CODECACHE_BlockSize</a> ()</td></tr>
<tr class="separator:gaaf55a4da7c062b4fedb4544d5ef95981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8af5ba8a4b6f1346ed468811339e4c"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabb8af5ba8a4b6f1346ed468811339e4c">LEVEL_PINCLIENT::CODECACHE_NumTracesInCache</a> ()</td></tr>
<tr class="separator:gabb8af5ba8a4b6f1346ed468811339e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946dc189f085d5f742be7b0a66db9d2d"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga946dc189f085d5f742be7b0a66db9d2d">LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache</a> ()</td></tr>
<tr class="separator:ga946dc189f085d5f742be7b0a66db9d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae89e0062f0129394fafae468a6bf8350"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae89e0062f0129394fafae468a6bf8350">LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock</a> (USIZE block_size)</td></tr>
<tr class="separator:gae89e0062f0129394fafae468a6bf8350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a69b3c0ecdbc972c3d79f98491f21d8"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga4a69b3c0ecdbc972c3d79f98491f21d8">LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit</a> (USIZE cache_size)</td></tr>
<tr class="separator:ga4a69b3c0ecdbc972c3d79f98491f21d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef157780b28486a4757270c00b66108"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga0ef157780b28486a4757270c00b66108">LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize</a> (USIZE block_size)</td></tr>
<tr class="separator:ga0ef157780b28486a4757270c00b66108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa057bcb372b7aae955e163e08e38bf82"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaa057bcb372b7aae955e163e08e38bf82">LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace</a> (UINT32 max_ins)</td></tr>
<tr class="separator:gaa057bcb372b7aae955e163e08e38bf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e1311e142234e705d6f6367b435428"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gae2e1311e142234e705d6f6367b435428">LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace</a> (UINT32 max_basic_blocks)</td></tr>
<tr class="separator:gae2e1311e142234e705d6f6367b435428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3773a88d72d3ceec4c35757e4beb2160"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3773a88d72d3ceec4c35757e4beb2160">LEVEL_PINCLIENT::CODECACHE_FlushCache</a> ()</td></tr>
<tr class="separator:ga3773a88d72d3ceec4c35757e4beb2160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab979188050e346d3c01a7de307e9cbe7"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gab979188050e346d3c01a7de307e9cbe7">LEVEL_PINCLIENT::CODECACHE_InvalidateRange</a> (ADDRINT start, ADDRINT end)</td></tr>
<tr class="separator:gab979188050e346d3c01a7de307e9cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2442ec5df29c4264fc2b0189ce1e0c2a"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga2442ec5df29c4264fc2b0189ce1e0c2a">LEVEL_PINCLIENT::INS_CodeCacheAddress</a> (INS ins)</td></tr>
<tr class="separator:ga2442ec5df29c4264fc2b0189ce1e0c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e95df926aa9a43fa77283c7c1d409a"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga68e95df926aa9a43fa77283c7c1d409a">LEVEL_PINCLIENT::BBL_CodeCacheAddress</a> (BBL bbl)</td></tr>
<tr class="separator:ga68e95df926aa9a43fa77283c7c1d409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3649ba022457e9fec1b4b894f161933c"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga3649ba022457e9fec1b4b894f161933c">LEVEL_PINCLIENT::TRACE_CodeCacheAddress</a> (TRACE trace)</td></tr>
<tr class="separator:ga3649ba022457e9fec1b4b894f161933c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da59177d8a31602356372817ac1c8e2"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga6da59177d8a31602356372817ac1c8e2">LEVEL_PINCLIENT::INS_CodeCacheSize</a> (INS ins)</td></tr>
<tr class="separator:ga6da59177d8a31602356372817ac1c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137cff9c8f26211b79bd129f864bb0a1"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga137cff9c8f26211b79bd129f864bb0a1">LEVEL_PINCLIENT::BBL_CodeCacheSize</a> (BBL bbl)</td></tr>
<tr class="separator:ga137cff9c8f26211b79bd129f864bb0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a68b7cb85cdb2a707bf1adb9f4714c"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga16a68b7cb85cdb2a707bf1adb9f4714c">LEVEL_PINCLIENT::TRACE_CodeCacheSize</a> (TRACE trace)</td></tr>
<tr class="separator:ga16a68b7cb85cdb2a707bf1adb9f4714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe51bc22d2bd5ced0bc5526cde76f8d9"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gabe51bc22d2bd5ced0bc5526cde76f8d9">LEVEL_PINCLIENT::CODECACHE_OriginalAddress</a> (ADDRINT cache_pc)</td></tr>
<tr class="separator:gabe51bc22d2bd5ced0bc5526cde76f8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ee054bf89f654d960556d145c600f6"><td class="memItemLeft" align="right" valign="top">USIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga85ee054bf89f654d960556d145c600f6">LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin</a> ()</td></tr>
<tr class="separator:ga85ee054bf89f654d960556d145c600f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf900f778c75812817d5badd5175ccef7"><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaf900f778c75812817d5badd5175ccef7">LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction</a> (TRACE_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>
<tr class="separator:gaf900f778c75812817d5badd5175ccef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API allows the user to inspect Pin's code cache and/or alter the code cache replacement policy. For example, to alter the replacement policy, a user can register a routine that is called anytime the cache is full.<br />
APIs from this group are available in any thread, including any internal thread spawned by the tool. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga37b85643fe15f437bd36330001b4ca5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK)(USIZE new_block_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when Pin's code cache adds a new cache block </p>

</div>
</div>
<a class="anchor" id="ga197457580426e1cef2a5251615a45bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK)(ADDRINT cache_pc)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when control enters or exits code cache </p>

</div>
</div>
<a class="anchor" id="gabe86a24a3af58f9fdf9f748c17ea0a25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK)(USIZE trace_size, USIZE stub_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when Pin's code cache is full </p>

</div>
</div>
<a class="anchor" id="ga3e65e760fb4fc84568a736ef3c0a062d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK)(ADDRINT branch_pc, ADDRINT target_pc)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when a trace is linked </p>

</div>
</div>
<a class="anchor" id="ga98bf4df2161b9cecbe77ffedfd0fd2f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK)()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function that passes no arguments </p>

</div>
</div>
<a class="anchor" id="ga506353952adfe0fe732bed4c2c45ea5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK)(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when Pin removes a region from the cache </p>

</div>
</div>
<a class="anchor" id="gac02c7c2aa22326a08955162d2dc0448a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK)(ADDRINT branch_pc, ADDRINT stub_pc)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function when a trace is unlinked </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga68e95df926aa9a43fa77283c7c1d409a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::BBL_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">BBL&#160;</td>
          <td class="paramname"><em>bbl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the starting code cache address of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Code Cache Address</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga137cff9c8f26211b79bd129f864bb0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::BBL_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">BBL&#160;</td>
          <td class="paramname"><em>bbl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the code cache footprint of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Size of the basic block in the code cache</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga379731c41320f38f44fa0fb40737d772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_CACHEBLOCK_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever a new cache block is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac75516b5a8e0a5e941f43d738a51b46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever the cache is physically flushed. Note that this event may occur later than the point at which the flush was first requested, either because we were in an analysis routine so it wasn't safe to flush, or because we are running a multithreaded application and we needed to wait for all threads to move out of the traces they were executing before we could flush. (But rest assured that no traces were entered between the time that the flush was requested and when this callback occurs.)</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga17a2b32092653d2487e78dbf95505f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called once, when the code cache is first formed.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3816f1497788aae88c27d7a041d37a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever control enters the code cache.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga903b8e0a548c984ea0fd608c1d11fec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever control exits the code cache.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f05396c442e2a2451975ab71ed9c568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_FULL_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever the cache fills up.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf900f778c75812817d5badd5175ccef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction </td>
          <td>(</td>
          <td class="paramtype">TRACE_INSTRUMENT_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever a trace is placed in the code cache.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf2c32577f894744a42be8cf0c32e0e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_TRACEINVALIDATED_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever a trace is invalidated in the code cache. (This means the trace will never be executed again, but the space is not reclaimed until a full code cache flush.</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gadb3f16e42bea2a508bb9f8c3c2ad03b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_LINKED_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever a trace is linked (backpatched)</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga04641b94094045fa3982373cb0281440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_UNLINKED_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function that gets called whenever a trace is unlinked (unpatched)</p>
<dl class="section return"><dt>Returns</dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaf55a4da7c062b4fedb4544d5ef95981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Default size (in bytes) of code cache allocation units (code cache blocks)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa12252f735d860ac0288435c0db72a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Current limit imposed on the memory allowed for storing traces and exit stubs</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0ef157780b28486a4757270c00b66108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>New default size for all future code cache blocks (regions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful change of default cache block size</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4a69b3c0ecdbc972c3d79f98491f21d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>cache_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a new limit to code cache size. The requested size will be rounded up to the nearest multiplication of the cache block size. See CODECACHE_ChangeBlockSize on changing the block size, and CODECACHE_CacheSizeLimit for checking the actual size limit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_size</td><td>New code cache size limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful change of max code cache size</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae2e1311e142234e705d6f6367b435428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>max_basic_blocks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_basic_blocks</td><td>The new limit of BBs per trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful change of basic block limit per trace</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa057bcb372b7aae955e163e08e38bf82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>max_ins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_ins</td><td>The new limit of instructions per trace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful change of instruction limit per trace</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga54123ca5c5d213041e46c3c47d1030a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemReserved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Memory size (bytes) reserved for code caching (traces and exit stubs)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga03d298cac03ab619c7d9575ca1bc4408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Bytes of code cache currently occupied by traces and exit stubs</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae89e0062f0129394fafae468a6bf8350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock </td>
          <td>(</td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>The size (in bytes) of the new code cache block (region) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful generation of a new code cache block</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga285de63369aba24328ddaecd8511e1df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Memory size (bytes) of the code cache directory data structures Note that this is a lower bound, as it is difficult to get an accurate account for the size of all of the data structures.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae8971f6762d05f83a017263d024db3c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_ExitStubBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Bytes of code cache currently occupied exit stubs</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3773a88d72d3ceec4c35757e4beb2160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_FlushCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine flushes the entire cache. We do not need to remove any links, as they will be flushed with the cache. </p><dl class="section return"><dt>Returns</dt><dd>Boolean success if the given cache was successfully flushed</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab979188050e346d3c01a7de307e9cbe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateRange </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unlinks and invalidates any traces in the code cache that correspond to any code in the given source program address range [start,end] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The original program starting address of the range we want to invalidate </td></tr>
    <tr><td class="paramname">end</td><td>The original program ending address (inclusive) of the range we want to invalidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Traces Invalidated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf39fec242a10c873fb397f5e3d523ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>app_pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates any traces starting at the given program address. Note: More than one trace may correspond to a single program address due to register allocation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app_pc</td><td>The original program address (must be a trace head) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of traces sucessfully invalidated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8f5165231ddc04eeb2694c58015855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_LinkBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Bytes of cache directory currently occupied by links</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga946dc189f085d5f742be7b0a66db9d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of exit stubs in the entire code cache</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabb8af5ba8a4b6f1346ed468811339e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumTracesInCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of traces in the entire code cache</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabe51bc22d2bd5ced0bc5526cde76f8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::CODECACHE_OriginalAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>cache_pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the original application address associated with the given code cache address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_pc</td><td>The address of the trace in the code cache (any address, not just start of trace) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original application address if it exists; zero is returned if no application address corresponds with the given code cache address.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2442ec5df29c4264fc2b0189ce1e0c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::INS_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the code cache address of any given instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Code Cache Address</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6da59177d8a31602356372817ac1c8e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::INS_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the code cache footprint of an instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Size of the instrution in the code cache</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga85ee054bf89f654d960556d145c600f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the amount (in bytes) of memory currently allocated by Pin for all internal structures and data. This is an accurate representation tracked through mmap calls. </p><dl class="section return"><dt>Returns</dt><dd>Bytes of allocated memory</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3649ba022457e9fec1b4b894f161933c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::TRACE_CodeCacheAddress </td>
          <td>(</td>
          <td class="paramtype">TRACE&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the starting code cache address of a trace (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Code Cache Address </dd></dl>

</div>
</div>
<a class="anchor" id="ga16a68b7cb85cdb2a707bf1adb9f4714c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::TRACE_CodeCacheSize </td>
          <td>(</td>
          <td class="paramtype">TRACE&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine determines the code cache footprint of a trace. If instrumentation is inlined into the trace, the footprint will include that space. (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p><dl class="section return"><dt>Returns</dt><dd>Size of the trace in the code cache</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 21 2015 02:13:23 for Pin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
