<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Pin: Pin Thread API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Pin Thread API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf45100643b9edc94ae0f0264e5d14fc3"><td class="memItemLeft" align="right" valign="top">typedef INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">LEVEL_BASE::TLS_KEY</a></td></tr>
<tr class="separator:gaf45100643b9edc94ae0f0264e5d14fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td></tr>
<tr class="separator:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memItemLeft" align="right" valign="top">typedef UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td></tr>
<tr class="separator:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b3270ac70a26730cb13e8481386765"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a></td></tr>
<tr class="separator:gac1b3270ac70a26730cb13e8481386765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d4b7206749ac3075b941a513d876c5"><td class="memItemLeft" align="right" valign="top">typedef VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> (VOID *arg)</td></tr>
<tr class="separator:gaf7d4b7206749ac3075b941a513d876c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf6029042d57fb825536c795c94d1ed"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td></tr>
<tr class="separator:ga2bf6029042d57fb825536c795c94d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f3c61bba77bd6fb9ad9b1d35db211e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga9f3c61bba77bd6fb9ad9b1d35db211e8">LEVEL_PINCLIENT::PIN_GetTid</a> ()</td></tr>
<tr class="separator:ga9f3c61bba77bd6fb9ad9b1d35db211e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a3364bd3d459fefa1cccf45571e4bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">LEVEL_PINCLIENT::PIN_ThreadId</a> ()</td></tr>
<tr class="separator:gaf7a3364bd3d459fefa1cccf45571e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e43d54c4e15ad1d9474fbf764e42a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga1e43d54c4e15ad1d9474fbf764e42a05">LEVEL_PINCLIENT::PIN_ThreadUid</a> ()</td></tr>
<tr class="separator:ga1e43d54c4e15ad1d9474fbf764e42a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57a3a8d9a6b4c107ad92e7990fb323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga0d57a3a8d9a6b4c107ad92e7990fb323">LEVEL_PINCLIENT::PIN_GetParentTid</a> ()</td></tr>
<tr class="separator:ga0d57a3a8d9a6b4c107ad92e7990fb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28935318ee1add7ae5f62b7afcb5ed97"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga28935318ee1add7ae5f62b7afcb5ed97">LEVEL_PINCLIENT::PIN_Sleep</a> (UINT32 milliseconds)</td></tr>
<tr class="separator:ga28935318ee1add7ae5f62b7afcb5ed97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b438c55e13bcd11ea3814818048d14"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga86b438c55e13bcd11ea3814818048d14">LEVEL_PINCLIENT::PIN_Yield</a> ()</td></tr>
<tr class="separator:ga86b438c55e13bcd11ea3814818048d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a4c5a6aa259ee6d89e856d5060b1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">LEVEL_PINCLIENT::PIN_SpawnInternalThread</a> (<a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *pThreadFunc, VOID *arg, size_t stackSize, <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *pThreadUid)</td></tr>
<tr class="separator:gae5a4c5a6aa259ee6d89e856d5060b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8579b9498909ffcd7afcc7520016b9"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga4f8579b9498909ffcd7afcc7520016b9">LEVEL_PINCLIENT::PIN_ExitThread</a> (INT32 exitCode)</td></tr>
<tr class="separator:ga4f8579b9498909ffcd7afcc7520016b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0602cd47412009126005c37fa1ee6205"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga0602cd47412009126005c37fa1ee6205">LEVEL_PINCLIENT::PIN_IsApplicationThread</a> ()</td></tr>
<tr class="separator:ga0602cd47412009126005c37fa1ee6205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf36c5795141e682ca2dff3f097681a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">LEVEL_PINCLIENT::PIN_WaitForThreadTermination</a> (const <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</td></tr>
<tr class="separator:gabcf36c5795141e682ca2dff3f097681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681b583239becd0b181f5b31e865931c"><td class="memItemLeft" align="right" valign="top">TLS_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">LEVEL_PINCLIENT::PIN_CreateThreadDataKey</a> (DESTRUCTFUN destruct_func)</td></tr>
<tr class="separator:ga681b583239becd0b181f5b31e865931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70a860606c7a8c28808b353e428813d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad70a860606c7a8c28808b353e428813d">LEVEL_PINCLIENT::PIN_DeleteThreadDataKey</a> (TLS_KEY key)</td></tr>
<tr class="separator:gad70a860606c7a8c28808b353e428813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268c8c79f3ea0b273240d2fb466a92f8"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga268c8c79f3ea0b273240d2fb466a92f8">LEVEL_PINCLIENT::PIN_SetThreadData</a> (TLS_KEY key, const VOID *data, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:ga268c8c79f3ea0b273240d2fb466a92f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b958f9981cd2b6de9eb442d8de85c4"><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga54b958f9981cd2b6de9eb442d8de85c4">LEVEL_PINCLIENT::PIN_GetThreadData</a> (TLS_KEY key, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:ga54b958f9981cd2b6de9eb442d8de85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7a22817a78367ba432a8121df3d7b461"><td class="memItemLeft" align="right" valign="top">GLOBALCONST TLS_KEY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga7a22817a78367ba432a8121df3d7b461">LEVEL_BASE::INVALID_TLS_KEY</a> =(-1)</td></tr>
<tr class="separator:ga7a22817a78367ba432a8121df3d7b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad783207300b6d463f018da9b9bebba7d"><td class="memItemLeft" align="right" valign="top">GLOBALCONST UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad783207300b6d463f018da9b9bebba7d">LEVEL_PINCLIENT::MAX_CLIENT_TLS_KEYS</a> = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td></tr>
<tr class="separator:gad783207300b6d463f018da9b9bebba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c8bec30de2cbb5336b3d2d7d817466"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#ga81c8bec30de2cbb5336b3d2d7d817466">INVALID_THREADID</a> = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&gt;(-1)</td></tr>
<tr class="separator:ga81c8bec30de2cbb5336b3d2d7d817466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae11dfbf7d439196f8d24d3e463c275b"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gaae11dfbf7d439196f8d24d3e463c275b">INVALID_PIN_THREAD_UID</a> = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&gt;(-1)</td></tr>
<tr class="separator:gaae11dfbf7d439196f8d24d3e463c275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad736d7bd6f0a29b0ca5c8ebb6153b9d0"><td class="memItemLeft" align="right" valign="top">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__THREAD__API.html#gad736d7bd6f0a29b0ca5c8ebb6153b9d0">INVALID_OS_THREAD_ID</a> = 0</td></tr>
<tr class="separator:gad736d7bd6f0a29b0ca5c8ebb6153b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A group of Pin threading primitives. These APIs are available in any thread, including any internal thread spawned by the tool. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2bf6029042d57fb825536c795c94d1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__PIN__THREAD__API.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process ID assigned by OS. </p>

</div>
</div>
<a class="anchor" id="gac1b3270ac70a26730cb13e8481386765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by OS. </p>

</div>
</div>
<a class="anchor" id="ga057233f26b54f23b1ddb0c0c5e31dba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT64 <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unique thread ID which, unlike THREADID identifier, is not reused by Pin after the thread termination. The uniqueness of this identifier allows to use it in the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function which monitors the thread's state. </p>

</div>
</div>
<a class="anchor" id="gaf7d4b7206749ac3075b941a513d876c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID ROOT_THREAD_FUNC(VOID *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main (starting) function of a thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function, as specified by the thread creator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga645289be59039349ad77ad2fa7b0e2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by PIN. </p>

</div>
</div>
<a class="anchor" id="gaf45100643b9edc94ae0f0264e5d14fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef INT32 <a class="el" href="group__PIN__THREAD__API.html#gaf45100643b9edc94ae0f0264e5d14fc3">LEVEL_BASE::TLS_KEY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type that represents TLS key - a unique identifier of a slot in the thread local storage. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga681b583239becd0b181f5b31e865931c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TLS_KEY LEVEL_PINCLIENT::PIN_CreateThreadDataKey </td>
          <td>(</td>
          <td class="paramtype">DESTRUCTFUN&#160;</td>
          <td class="paramname"><em>destruct_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new TLS key and associate it with a given data destruction function. Upon successful return, any thread of the process can use <a class="el" href="group__PIN__THREAD__API.html#ga268c8c79f3ea0b273240d2fb466a92f8">PIN_SetThreadData()</a> and <a class="el" href="group__PIN__THREAD__API.html#ga54b958f9981cd2b6de9eb442d8de85c4">PIN_GetThreadData()</a> functions to store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. At the thread exit, if a key has a non-NULL pointer to the cleanup (destruction) function, and the thread has a non-NULL value in the corresponding slot, the function is called with the slot's value as its sole argument. The order in which destructors are invoked is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destructFun</td><td>optional parameter that specifies data destruction function to be associated with the new key. This function is called just after notifying the client about VM thread exit. By default (NULL destructor), the data is not cleaned up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated TLS key, upon success; -1, if number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad70a860606c7a8c28808b353e428813d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_DeleteThreadDataKey </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release TLS key, allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. The function has no effect if specified key is not allocated/already released. After the key is released, a client should not attempt to use it for any further TLS access. Doing otherwise results in undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, upon success; FALSE, if if specified key is invalid</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4f8579b9498909ffcd7afcc7520016b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ExitThread </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminate the current thread.</p>
<p>This function is intended for threads created by the tool (see <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>) and is not normally used for threads created by the application, since application threads exit automatically when Pin executes a thread termination system call on their behalf.</p>
<p>If this call is made on an application thread, Pin will make any callbacks registered for thread exit before the thread is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exitCode</td><td>exit code of the thread to be returned by the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the function never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0d57a3a8d9a6b4c107ad92e7990fb323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_GetParentTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get system identifier of the parent thread, if known. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the parent thread or INVALID_OS_THREAD_ID if the parent thread is unknown. On Windows the result is always INVALID_OS_THREAD_ID, since there is, in general, no well defined parent child relationship between threads.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga54b958f9981cd2b6de9eb442d8de85c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_GetThreadData </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value stored in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, whose value is requested. The key should be allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value stored in the specified slot of the thread, if specified key is currently allocated; NULL, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9f3c61bba77bd6fb9ad9b1d35db211e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_GetTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get system identifier of the current thread. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the current thread.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0602cd47412009126005c37fa1ee6205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsApplicationThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the current thread is created by the application or it is an internal thread spawned by the tool or Pin itself (see <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if this function is called in a thread created by the application; FALSE, if this function is called in an internal thread spawned by the tool or Pin.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga268c8c79f3ea0b273240d2fb466a92f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_SetThreadData </td>
          <td>(</td>
          <td class="paramtype">TLS_KEY&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store specified value in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, where the value will be stored upon successful return. The key should be allocated by a previous call to the <a class="el" href="group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>value to be stored in the TLS slot of the current thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if specified key is currently allocated; FALSE, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga28935318ee1add7ae5f62b7afcb5ed97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Sleep </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay execution of the current thread for the specified time interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time interval, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae5a4c5a6aa259ee6d89e856d5060b1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> LEVEL_PINCLIENT::PIN_SpawnInternalThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *&#160;</td>
          <td class="paramname"><em>pThreadFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *&#160;</td>
          <td class="paramname"><em>pThreadUid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tool internal thread in the current process.</p>
<p>It is safe to create internal threads in the tool's main procedure and spawn new internal threads from existing ones. However new application threads cannot be created in any other places, like Pin callbacks and analysis routines in application threads.<br />
 In order to ensure graceful termination of internal threads on the application's exit, the tool can use one of the following recommended methods:</p><ul>
<li>All tool threads periodically check the state of the application process by calling the PIN_IsProcessExiting function. If this function indicates that the application process is about to terminate, the threads either return or call the <a class="el" href="group__PIN__THREAD__API.html#ga4f8579b9498909ffcd7afcc7520016b9">PIN_ExitThread()</a> function as soon as possible. The grace period for Pin to wait for the termination of tool threads can be specified with the -tool_exit_timeout command line switch.<br />
</li>
<li>The tool uses the <a class="el" href="group__PIN__CONTROL.html#ga6fdc217f8b88d50515ffd9643592dc68">PIN_AddFiniUnlockedFunction()</a> function to register a FINI_CALLBACK callback. When the registered function is called in an "unlocked" application thread, the tool requests each internal thread to exit and waits until the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function returns.</li>
</ul>
<p>Many of Pin's APIs, that are primarily intended for application threads, are also available in internal threads. Look at the API's description ( <b>Availability</b> paragraph) or the description of the corresponding group of APIs to check whether a specific API is available in internal threads.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pThreadFunc</td><td>main (starting) function of the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>size of the thread's stack, in bytes. The function rounds this value up to the page size. If this parameter is zero, DEFAULT_THREAD_STACK_SIZE bytes will be allocated for the stack. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pThreadUid</td><td>pointer to a variable that receives the unique identifier of the new thread in Pin. This identifier can be used in the <a class="el" href="group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a">PIN_WaitForThreadTermination()</a> function to monitor the thread's state. If the caller specifies NULL for this parameter, the unique thread ID is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the new thread in Pin or INVALID_THREADID if the thread creation failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> API is the only way for tools to create a private thread in the Pin-controlled process. System services, like CreateThread() in Windows or clone() in Linux should not be used for this purpose. </dd></dl>
<dl class="section user"><dt></dt><dd>Pin makes an effort to hide internal threads from the application so, usually, a tool's threads do not interfere with the application. However, the complete transparency of internal threads is not guaranteed, so tools should only use them when their instrumentation tasks cannot be done (effectively) by analysis routines within application threads. For example, a need to execute Windows services (Win32 APIs) may be a reason for creating a private thread in the tool. All Win32 APIs that do not modify the application's resources can be freely used in internal threads. In application threads, on the contrary, using Win32 APIs in analysis routines and Pin callbacks is not supported due to possible reentrancy and isolation problems. </dd></dl>
<dl class="section user"><dt></dt><dd>Internal threads remain blocked inside Pin until <a class="el" href="group__PIN__CONTROL.html#ga70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a> is called and Pin completes some initialization. On Linux, internal threads start running <em>pThreadFunc</em> before Pin executes the first application instruction. On Windows all threads, including Pin internal threads, start executing from the system runtime before they execute the <em>pThreadFunc</em> function. However, the system runtime blocks threads until the application has finished initializing its DLL's (i.e. until the application releases the internal "loader lock"). As a result, Pin internal threads on Windows do not execute <em>pThreadFunc</em> until after the application finishes executing the DLL initialization code.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf7a3364bd3d459fefa1cccf45571e4bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> LEVEL_PINCLIENT::PIN_ThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>ID of the current thread in Pin or INVALID_THREADID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1e43d54c4e15ad1d9474fbf764e42a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> LEVEL_PINCLIENT::PIN_ThreadUid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get unique identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>Unique ID of the current thread in Pin or INVALID_PIN_THREAD_UID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabcf36c5795141e682ca2dff3f097681a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_WaitForThreadTermination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;&#160;</td>
          <td class="paramname"><em>threadUid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32 *&#160;</td>
          <td class="paramname"><em>pExitCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay the current thread until the specified thread is terminated or the time-out interval elapses.</p>
<p>To avoid deadlocks, the caller should not hold any lock that the target thread may try to acquire. For example, this function can be safely used in the FINI_CALLBACK callback if it is registered by the <a class="el" href="group__PIN__CONTROL.html#ga6fdc217f8b88d50515ffd9643592dc68">PIN_AddFiniUnlockedFunction()</a>. However, it is not recommended to use this function in other Pin callbacks if the target thread is an application thread or an internal thread that uses Pin APIs. This is because most of Pin APIs and callbacks are serialized by the same internal lock.<br />
 This function can not be used to wait for the termination of the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadUid</td><td>unique identifier of the thread to be waited for termination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time-out interval, in milliseconds. If this parameter is zero, the function tests the thread's state and returns immediately. If this parameter is PIN_INFINITE_TIMEOUT, the time-out interval never elapses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExitCode</td><td>optional pointer to a variable that receives exit code of the thread. If this pointer is NULL or the thread has not terminated, the exit code is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - the thread has terminated, FALSE - the specified time-out interval elapsed.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux, Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga86b438c55e13bcd11ea3814818048d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield the processor to another thread.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; MacOS<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gad736d7bd6f0a29b0ca5c8ebb6153b9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#gac1b3270ac70a26730cb13e8481386765">OS_THREAD_ID</a> INVALID_OS_THREAD_ID = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the OS_THREAD_ID type. </p>

</div>
</div>
<a class="anchor" id="gaae11dfbf7d439196f8d24d3e463c275b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> INVALID_PIN_THREAD_UID = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the PIN_THREAD_UID type. </p>

</div>
</div>
<a class="anchor" id="ga81c8bec30de2cbb5336b3d2d7d817466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> INVALID_THREADID = static_cast&lt;<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the THREADID type. </p>

</div>
</div>
<a class="anchor" id="ga7a22817a78367ba432a8121df3d7b461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST TLS_KEY LEVEL_BASE::INVALID_TLS_KEY =(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the TLS_KEY type. </p>

</div>
</div>
<a class="anchor" id="gad783207300b6d463f018da9b9bebba7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLOBALCONST UINT32 LEVEL_PINCLIENT::MAX_CLIENT_TLS_KEYS = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of TLS keys that can be allocated by tool </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 21 2015 02:13:23 for Pin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
